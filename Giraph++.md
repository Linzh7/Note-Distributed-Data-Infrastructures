[From "Think Like a Vertex" to "Think Like a Graph"](http://www.vldb.org/pvldb/vol7/p193-tian.pdf)

[[Pregel]] as a distributed system, aims to process graph data in a faster rate. The key concept of Pregel and its open-source implementations is to consider the vertices as the key points of calculation on the divided graph partitions. However, this method prevents future optimization algorithms from being applied to graphs. To address this issue, researchers proposed the Giraph++ method, which allows data to flow freely within their partition without superstepping.

If we compare with other distributed graph processing systems, it is not hard to find some similarity. For example, Giraph++ updates information between supersteps like [[Pregel]]. However, Giraph++ allows updating data in the partition even without superstep to accelerate the communication process, while Pregel and other graph process system can only update between supersteps. The authors of this paper believe graph-centric models can exist in parallel with vertex-centered models. Additionally, graph-centric models have various benefits, including lower-level optimizations. Moreover, [[Pregel]] uses messages to update information between vertexes, which results in an excessive amount of traffic. Additionally, GraphLab is struggling with maintaining the consistency, and the price is too much scheduling work. Giraph++ opened the structure of partitions to users, which can reduce the overhead by intra-partition communication. Moreover, Pregel use hash partitioning, which also is a limit for performance. According to the experiment result, graph partitioning is the alternative solution that can effectively improve performance.

Unlike [[Giraph]], Giraph++ gives the whole perspective of this subgraph to programmers. Each subgraph maintains the value of vertexes and edges. Moreover, a subgraph also includes boundary vertexes but only maintains the vertexes themselves instead of both vertexes and edges. In this way, each subgraph can keep local copies of boundary vertexes and use those copies in order to pass messages to the primary copy. The distinction between internal vertices and boundary vertices is important because it is an effective way to reduce message exchange traffic. In this situation, the vertices do not have to update themselves until the next superstep. However, if it is a boundary vertex, the changes should be cast to the primary copy. Graph partitioning algorithms are also important for graph processing systems. An ideal partitioning approach can significantly decrease the number of edges that cross two subgraphs, and this will also reduce the volume of message traffic. Therefore, a multilevel k-way graph partitioning algorithm is used to address the problem. From the results, almost all models get benefits from this algorithm.

For the implementations of Giraph++, the biggest difference from previous systems is the *GraphPartition* class. GraphPartition is aimed at providing subgraph-level access and control. Moreover, the function users define in GraphPartition is also subgraph-level, which enables programmers to use some highly optimized algorithms for transmitting on subgraphs. Besides, they inherited the Vertex class from [[Giraph]], but only kept a part of the function for boundary vertexes. Moreover, only internal vertices have states to trace the states. As we mentioned before, it is possible to use a graph-centric model and a vertex-centric model at the same time, named *hybrid model*. In this situation, the system provides *inboxes* for each vertex to distinguish internal messages from external messages. This method make computing processes much faster with asynchronous computation, meanwhile do not have to rewrite the vertex-based algorithm.



