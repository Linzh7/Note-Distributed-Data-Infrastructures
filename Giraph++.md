[From "Think Like a Vertex" to "Think Like a Graph"](http://www.vldb.org/pvldb/vol7/p193-tian.pdf)

[[Pregel]] as a distributed system, aims to process graph data. However, Pregel and its open-source implementations divide the whole graph into lots of partitions, which consider the vertices as the keypoint of calculation. However, this method prevents future optimization algorithms from being applied to graphs.

If we compare with other distributed graph processing systems, it is not hard to find some similarity. For example, Giraph++ updates information between supersteps like [[Pregel]]. However, Giraph++ allows updating data in the partition to accelerate the communication process. The authors of this paper believe graph-centric models can exist in parallel with vertex-centered models. Additionally, graph-centric models have various benefits, including lower-level optimizations. Moreover, [[Pregel]] uses messages to update information between vertexes, which results in an excessive amount of traffic. Additionally, GraphLab is struggling with maintaining the consistency, and the price is too much scheduling work. Giraph++ opened the structure of partitions to users, which can reduce the overhead by intra-partition communication. As a result, Giraph++ has a better performance.

Unlike [[Giraph]], Giraph++ gives the whole perspective of this subgraph to programmers. Each subgraph maintains the value of vertexes and edges. Moreover, a subgraph also includes boundary vertexes but only maintains the vertexes themselves instead of both vertexes and edges. In this way, each subgraph can keep local copies of boundary vertexes and use those copies in order to pass messages to the primary copy. The distinction between internal vertices and boundary vertices is important because it is an effective way to reduce message exchange traffic. In this situation, the vertices do not have to update themselves until the next superstep. However, if it is a boundary vertex, the changes should be cast to the primary copy. Graph partitioning algorithms are also important for graph processing systems. An ideal partitioning approach can significantly decrease the number of edges that cross two subgraphs, and this will also reduce the volume of message traffic. Therefore, a multilevel k-way graph partitioning algorithm is used to address the problem. From the results, almost all models get benefits from this algorithm.

For the implements of Giraph++, the biggest different from previous systems is the *GraphPartition* class. GraphPartition is aimed to provide subgraph-level access and control. 
Moreover, the function users define in GraphPartition is also subgraph-level, which enable programmers to use some highly optimized algorithm for transmitting on subgraphs. Besides, they inherited the Vertex class from [[Giraph]], but only keep a part of the function for boundary vertexes. Moreover, only internal vertices have states to trace the states. As we mentioned before, it is possible to use